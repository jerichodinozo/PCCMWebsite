{"ast":null,"code":"const defaultOptions = {\n  active: true,\n  breakpoints: {},\n  delay: 4000,\n  jump: false,\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  stopOnLastSnap: false,\n  rootNode: null\n};\nfunction Autoplay() {\n  let userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let options;\n  let emblaApi;\n  let destroyed;\n  let playing = false;\n  let resume = true;\n  let jump = false;\n  let timer = 0;\n  function init(emblaApiInstance, optionsHandler) {\n    emblaApi = emblaApiInstance;\n    const {\n      mergeOptions,\n      optionsAtMedia\n    } = optionsHandler;\n    const optionsBase = mergeOptions(defaultOptions, Autoplay.globalOptions);\n    const allOptions = mergeOptions(optionsBase, userOptions);\n    options = optionsAtMedia(allOptions);\n    if (emblaApi.scrollSnapList().length <= 1) return;\n    jump = options.jump;\n    destroyed = false;\n    const {\n      eventStore,\n      ownerDocument\n    } = emblaApi.internalEngine();\n    const emblaRoot = emblaApi.rootNode();\n    const root = options.rootNode && options.rootNode(emblaRoot) || emblaRoot;\n    const container = emblaApi.containerNode();\n    emblaApi.on('pointerDown', stopTimer);\n    if (!options.stopOnInteraction) {\n      emblaApi.on('pointerUp', startTimer);\n    }\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', () => {\n        resume = false;\n        stopTimer();\n      });\n      if (!options.stopOnInteraction) {\n        eventStore.add(root, 'mouseleave', () => {\n          resume = true;\n          startTimer();\n        });\n      }\n    }\n    if (options.stopOnFocusIn) {\n      eventStore.add(container, 'focusin', stopTimer);\n      if (!options.stopOnInteraction) {\n        eventStore.add(container, 'focusout', startTimer);\n      }\n    }\n    eventStore.add(ownerDocument, 'visibilitychange', visibilityChange);\n    if (options.playOnInit && !documentIsHidden()) startTimer();\n  }\n  function destroy() {\n    emblaApi.off('pointerDown', stopTimer).off('pointerUp', startTimer);\n    stopTimer();\n    destroyed = true;\n    playing = false;\n  }\n  function startTimer() {\n    if (destroyed) return;\n    if (!resume) return;\n    if (!playing) emblaApi.emit('autoplay:play');\n    const {\n      ownerWindow\n    } = emblaApi.internalEngine();\n    ownerWindow.clearInterval(timer);\n    timer = ownerWindow.setInterval(next, options.delay);\n    playing = true;\n  }\n  function stopTimer() {\n    if (destroyed) return;\n    if (playing) emblaApi.emit('autoplay:stop');\n    const {\n      ownerWindow\n    } = emblaApi.internalEngine();\n    ownerWindow.clearInterval(timer);\n    timer = 0;\n    playing = false;\n  }\n  function visibilityChange() {\n    if (documentIsHidden()) {\n      resume = playing;\n      return stopTimer();\n    }\n    if (resume) startTimer();\n  }\n  function documentIsHidden() {\n    const {\n      ownerDocument\n    } = emblaApi.internalEngine();\n    return ownerDocument.visibilityState === 'hidden';\n  }\n  function play(jumpOverride) {\n    if (typeof jumpOverride !== 'undefined') jump = jumpOverride;\n    resume = true;\n    startTimer();\n  }\n  function stop() {\n    if (playing) stopTimer();\n  }\n  function reset() {\n    if (playing) play();\n  }\n  function isPlaying() {\n    return playing;\n  }\n  function next() {\n    const {\n      index\n    } = emblaApi.internalEngine();\n    const nextIndex = index.clone().add(1).get();\n    const lastIndex = emblaApi.scrollSnapList().length - 1;\n    const kill = options.stopOnLastSnap && nextIndex === lastIndex;\n    if (kill) stopTimer();\n    if (emblaApi.canScrollNext()) {\n      emblaApi.scrollNext(jump);\n    } else {\n      emblaApi.scrollTo(0, jump);\n    }\n  }\n  const self = {\n    name: 'autoplay',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying\n  };\n  return self;\n}\nAutoplay.globalOptions = undefined;\nexport { Autoplay as default };","map":{"version":3,"names":["defaultOptions","active","breakpoints","delay","jump","playOnInit","stopOnFocusIn","stopOnInteraction","stopOnMouseEnter","stopOnLastSnap","rootNode","Autoplay","userOptions","arguments","length","undefined","options","emblaApi","destroyed","playing","resume","timer","init","emblaApiInstance","optionsHandler","mergeOptions","optionsAtMedia","optionsBase","globalOptions","allOptions","scrollSnapList","eventStore","ownerDocument","internalEngine","emblaRoot","root","container","containerNode","on","stopTimer","startTimer","add","visibilityChange","documentIsHidden","destroy","off","emit","ownerWindow","clearInterval","setInterval","next","visibilityState","play","jumpOverride","stop","reset","isPlaying","index","nextIndex","clone","get","lastIndex","kill","canScrollNext","scrollNext","scrollTo","self","name"],"sources":["/Users/jerichodinozo/Desktop/WebProjects/PCCMWebsite/node_modules/embla-carousel-autoplay/src/components/Options.ts","/Users/jerichodinozo/Desktop/WebProjects/PCCMWebsite/node_modules/embla-carousel-autoplay/src/components/Autoplay.ts"],"sourcesContent":["import { CreateOptionsType } from 'embla-carousel'\n\nexport type OptionsType = CreateOptionsType<{\n  delay: number\n  jump: boolean\n  playOnInit: boolean\n  stopOnFocusIn: boolean\n  stopOnInteraction: boolean\n  stopOnMouseEnter: boolean\n  stopOnLastSnap: boolean\n  rootNode: ((emblaRoot: HTMLElement) => HTMLElement | null) | null\n}>\n\nexport const defaultOptions: OptionsType = {\n  active: true,\n  breakpoints: {},\n  delay: 4000,\n  jump: false,\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  stopOnLastSnap: false,\n  rootNode: null\n}\n","import { OptionsType, defaultOptions } from './Options'\nimport {\n  CreatePluginType,\n  OptionsHandlerType,\n  EmblaCarouselType\n} from 'embla-carousel'\n\ndeclare module 'embla-carousel' {\n  interface EmblaPluginsType {\n    autoplay: AutoplayType\n  }\n\n  interface EmblaEventListType {\n    autoplayPlay: 'autoplay:play'\n    autoplayStop: 'autoplay:stop'\n  }\n}\n\nexport type AutoplayType = CreatePluginType<\n  {\n    play: (jump?: boolean) => void\n    stop: () => void\n    reset: () => void\n    isPlaying: () => boolean\n  },\n  OptionsType\n>\n\nexport type AutoplayOptionsType = AutoplayType['options']\n\nfunction Autoplay(userOptions: AutoplayOptionsType = {}): AutoplayType {\n  let options: OptionsType\n  let emblaApi: EmblaCarouselType\n  let destroyed: boolean\n  let playing = false\n  let resume = true\n  let jump = false\n  let timer = 0\n\n  function init(\n    emblaApiInstance: EmblaCarouselType,\n    optionsHandler: OptionsHandlerType\n  ): void {\n    emblaApi = emblaApiInstance\n\n    const { mergeOptions, optionsAtMedia } = optionsHandler\n    const optionsBase = mergeOptions(defaultOptions, Autoplay.globalOptions)\n    const allOptions = mergeOptions(optionsBase, userOptions)\n    options = optionsAtMedia(allOptions)\n\n    if (emblaApi.scrollSnapList().length <= 1) return\n\n    jump = options.jump\n    destroyed = false\n\n    const { eventStore, ownerDocument } = emblaApi.internalEngine()\n    const emblaRoot = emblaApi.rootNode()\n    const root = (options.rootNode && options.rootNode(emblaRoot)) || emblaRoot\n    const container = emblaApi.containerNode()\n\n    emblaApi.on('pointerDown', stopTimer)\n\n    if (!options.stopOnInteraction) {\n      emblaApi.on('pointerUp', startTimer)\n    }\n\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', () => {\n        resume = false\n        stopTimer()\n      })\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(root, 'mouseleave', () => {\n          resume = true\n          startTimer()\n        })\n      }\n    }\n\n    if (options.stopOnFocusIn) {\n      eventStore.add(container, 'focusin', stopTimer)\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(container, 'focusout', startTimer)\n      }\n    }\n\n    eventStore.add(ownerDocument, 'visibilitychange', visibilityChange)\n\n    if (options.playOnInit && !documentIsHidden()) startTimer()\n  }\n\n  function destroy(): void {\n    emblaApi.off('pointerDown', stopTimer).off('pointerUp', startTimer)\n    stopTimer()\n    destroyed = true\n    playing = false\n  }\n\n  function startTimer(): void {\n    if (destroyed) return\n    if (!resume) return\n    if (!playing) emblaApi.emit('autoplay:play')\n    const { ownerWindow } = emblaApi.internalEngine()\n    ownerWindow.clearInterval(timer)\n    timer = ownerWindow.setInterval(next, options.delay)\n    playing = true\n  }\n\n  function stopTimer(): void {\n    if (destroyed) return\n    if (playing) emblaApi.emit('autoplay:stop')\n    const { ownerWindow } = emblaApi.internalEngine()\n    ownerWindow.clearInterval(timer)\n    timer = 0\n    playing = false\n  }\n\n  function visibilityChange(): void {\n    if (documentIsHidden()) {\n      resume = playing\n      return stopTimer()\n    }\n\n    if (resume) startTimer()\n  }\n\n  function documentIsHidden(): boolean {\n    const { ownerDocument } = emblaApi.internalEngine()\n    return ownerDocument.visibilityState === 'hidden'\n  }\n\n  function play(jumpOverride?: boolean): void {\n    if (typeof jumpOverride !== 'undefined') jump = jumpOverride\n    resume = true\n    startTimer()\n  }\n\n  function stop(): void {\n    if (playing) stopTimer()\n  }\n\n  function reset(): void {\n    if (playing) play()\n  }\n\n  function isPlaying(): boolean {\n    return playing\n  }\n\n  function next(): void {\n    const { index } = emblaApi.internalEngine()\n    const nextIndex = index.clone().add(1).get()\n    const lastIndex = emblaApi.scrollSnapList().length - 1\n    const kill = options.stopOnLastSnap && nextIndex === lastIndex\n\n    if (kill) stopTimer()\n\n    if (emblaApi.canScrollNext()) {\n      emblaApi.scrollNext(jump)\n    } else {\n      emblaApi.scrollTo(0, jump)\n    }\n  }\n\n  const self: AutoplayType = {\n    name: 'autoplay',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying\n  }\n  return self\n}\n\ndeclare namespace Autoplay {\n  let globalOptions: AutoplayOptionsType | undefined\n}\n\nAutoplay.globalOptions = undefined\n\nexport default Autoplay\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}